#### 内存管理机制：

主要分为下面三部分：

1. 内存池机制：对于python来说，对象的类型都是运行时确定的，所以python的对象都是动态类型，简单来说，python内存分为四个部分：object mem 、mem pool 、 C malloc/free 、 OS
   1. 对于小内存(小于256k)，直接从mem pool中申请资源
   2. 对于大内存，调用c malloc进行分配资源
      **经由内存池分配的内存释放时还会回收到内存池中，并不会调用C的free进行释放**
   3. 改变对象内容对引用对象的影响：
      1. 假设一个对象A，将A对象赋值给B：
      2. 如果A是数值、字符串、元组等不可变对象的时候，当修改A的内容，B的内容不会改变，A的内存地址发生了改变
      3. 如果A是字典或者列表，当修改A的内容时，B的内容也会改变，但是对象A和B的地址不会发生改变
2. 引用计数：
   1. 增加引用计数的场景：
      1. 对象被创建 x = 4
      2. 对象被引用 y = x
      3. 被用作参数传递
      4. 作为容器的一个元素
   2. 引用计数减少的场景：
      1. 本地引用离开了作用域
      2. 对象别名被显示销毁del
      3. 对象的一个别名被赋值给其他对象 x = 123
      4. 对象从容器中被移除
      5. 容器对象被销毁，内部元素的引用计数都会减
3. 垃圾回收
   1. 当内存中有不在使用的部分时，垃圾收集器就会把他们清理掉，垃圾收集器会检查引用计数为0的对象，然后清除内存空间。当然除了引用计数为0的会被清理，还有一种情况也会被清理：当两个对象互相引用并没有其他的地方被引用的时候
   2. 垃圾回收机制还有一个循环垃圾回收器，确保释放循环引用对象。垃圾回收时，python不能进行其他任务。频繁的垃圾回收会大大降低python的工作效率，如果内存中的对象不多，就没有必要总是启动垃圾回收，所以，python在特定情况下才自动启动垃圾回收，当python运行时，会记录其中分配对象和取消对象的次数，当两者的差值高于某个阈值时，垃圾回收才会启动，也可以手动启动垃圾回收，即ga.collect()。
   3. python采取了分代回收的策略，这一策略的基本假设是，存活时间越久的对象，越不可能在后面的程序中变成垃圾，那么就启动对0代和1代的扫描清理。当一代经历了一定次数的垃圾回收之后，那么就会启动对0，1，2，即所有对象进行扫描清理

