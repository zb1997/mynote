## 第一篇：TCP/IP协议详解

#### 第一章：TCP/IP协议族

1. 体系结构和主要结构：
   1. 数据链路层：实现网卡接口的网络驱动程序，处理数据在物理媒介上的传输。协议有ARP和RARP。在网络层使用IP寻址，链路层使用MAC地址寻址。RARP协议一般是使用在没有存储设备的机器上，他们利用网卡上的物理地址向网络管理者(通常存有所有机器的IP地址映射)查询自身ip
   2. 网络层：实现数据包的选路和转发。最主要的协议是IP协议和ICMP协议，ICMP协议是IP协议的重要补充，主要用与检测网络连接。注意ICMP协议不是严格意义上的网络层协议，因为它使用同层的IP协议提供服务
   3. 传输层：为两台主机上的应用层提供端到端的通信。他为上层的应用提供一条端到端的通信链路,并负责数据的可靠性等.主要的协议有TCP、UDP、SCTP
   4. 应用层：负责处理应用程序逻辑。链路层传输层负责通信的细节，这部分必须稳定高效。所以他们在内核空间中实现，而应用层在用户空间实现。也有少数的服务器程序是在内核中实现的，这样代码就没有必要在用户空间和内核中切换，提高工作效率。但是这种代码实现复杂，可移植性差。应用层的协议很多，如telnet、ftp、ospf 、dns等
   
2. 封装和分用：
   
   1. 封装：![image-20210306150718095](https://github.com/zb1997/mynote/blob/main/tupian/image-20210306150718095.png)
   2. 分用：![image-20210306150805808](https://github.com/zb1997/mynote/blob/main/tupian/image-20210306150805808.png)
   
3. ARP和DNS工作原理

4. socket和TCP/IP协议族的关系

   > 数据链路层、 网络层、 传输层协议是在内核中实现的。 因此操作系统需要实现一组系统调用， 使得应用程序能够访问这些协议提供的服务。 实现这组系统调用的API（Application Programming Interface， 应用程序编程接口） 主要有两套： socket和XTI。 XTI现在基本不再使用， 本书仅讨论socket。 图1-1显示了socket与TCP/IP协议族的关系。
   >
   > 由socket定义的这一组API提供如下两点功能： 一是将应用程序数据从用户缓冲区中复制到TCP/UDP内核发送缓冲区， 以交付内核来发送数据（比如图1-5所示的send函数） ， 或者是从内核TCP/UDP接收缓冲区中复制数据到用户缓冲区， 以读取数据； 二是应用程序可以通过它们来修改内核中各层协议的某些头部信息或其他数据结构， 从而精细地控制底层通信的行为。 比如可以通过setsockopt函数来设置IP数据报在网络上的存活时间。 我们将在第5章详细讨论这一组API。
   > 值得一提的是， socket是一套通用网络编程接口， 它不但可以访问内核中TCP/IP协议栈， 而且可以访问其他网络协议栈（比如X.25协议栈、 UNIX本地域协议栈等） 。  
   
   

#### 第二章：IP协议详解

1. 特点：无状态、无连接、不可靠

   1. IP通信的双方不传输数据的状态，传输层控制状态。所以IP层简单高效，无需为保持通信的状态分配额外的资源
   2. 无连接指的是双方都不长久的维持对方的任何信息，上层协议每次发送数据的时候都需要明确指定对方的地址
   3. 不可靠值IP协议不保证IP数据包能够准确的到达接收端，只承诺最大努力交付

2. 结构：头部结构以及个字段含义：百度很清楚

   1. 松散路由选择(loose source routing)，只是给出IP数据报必须经过的一些"要点"，并不给出一条完备的路径，无直接连接的路由器之间的路由尚需IP软件的寻址
   2. 严格路由选择(strict source routing)，规定IP数据报要经过路径上的每一个路由器，相邻路由器之间不得有中间路由器，并且所经过路由器的顺序不可更改。

3. IP分片：当数据包的长度超过帧的MTU时，他将会被分片传输，分片可能发生在发送端，也可能会发生在中转路由器上，但是只有在目标机器上才会发生重组。IP头部有分片相关的字段

4. IP路由：

   1. IP模块工作流程![image-20210306152702658](https://github.com/zb1997/mynote/blob/main/tupian/image-20210306152702658.png)

      > 当IP模块接收到来自数据链路层的IP数据报时， 它首先对该数据报的头部做CRC校验， 确认无误之后就分析其头部的具体信息。
      > 如果该IP数据报的头部设置了源站选路选项（松散源路由选择或严格源路由选择） ， 则IP模块调用数据报转发子模块来处理该数据报。 如果该IP数据报的头部中目标IP地址是本机的某个IP地址， 或者是广播地址， 即该数据报是发送给本机的， 则IP模块就根据数据报头部中的协议字段来决定将它派发给哪个上层应用（分用） 。 如果IP模块发现这个数据报不是发送给本机的， 则也调用数据报转发子模块来处理该数据报。  数据报转发子模块将首先检测系统是否允许转发， 如果不允许， IP模块就将数据报丢弃。 如果允许，数据报转发子模块将对该数据报执行一些操作， 然后将它交给IP数据报输出子模块。 我们将在后面讨论数据报转发的具体过程。
      > IP数据报应该发送至哪个下一跳路由（或者目标机器） ， 以及经过哪个网卡来发送， 就是IP路由过程，即图2-3中“计算下一跳路由”子模块。 IP模块实现数据报路由的核心数据结构是路由表。 这个表按照数据报的目标IP地址分类， 同一类型的IP数据报将被发往相同的下一跳路由器（或者目标机器） 。 我们将在后面讨论IP路由过程。
      > IP输出队列中存放的是所有等待发送的IP数据报， 其中除了需要转发的IP数据报外， 还包括封装了本机上层数据（ICMP报文、 TCP报文段和UDP数据报） 的IP数据报。
      > 图2-3中的虚线箭头显示了路由表更新的过程。 这一过程是指通过路由协议或者route命令调整路由表，使之更适应最新的网络拓扑结构， 称为IP路由策略。 我们将在后面简单讨论它。  

5. ICMP重定向

6. IPV6头部结构

#### 第三章：TCP协议详解：

1. TCP服务的特点

   1. 主要特点：面向连接、字节流、提供可靠传输
   2. 字节流的概念：发送端的写操作和接收端的读操作的次数之间没有任何关系，当发送端应用程序连续执行多次写操作是，TCP模块会先将数据放到发送缓冲区，当TCP模块真的开始发送数据时，缓冲区的数据会被封装成一个或者多个TCP报文发送出去，因此，发送端的TCP包的数量和写操作没有关系，同理接收端也没有任何关系
   3. TCP字节流和UDP数据报：![image-20210306153555121](https://github.com/zb1997/mynote/blob/main/tupian/image-20210306153555121.png)

2. TCP头部结构

3. TCP连接的建立和关闭

   1. 三次握手和四次挥手
   2. 半关闭状态
   3. 连接超时

4. TCP状态转移

   1. 状态转移图![image-20210306153831889](https://github.com/zb1997/mynote/blob/main/tupian/image-20210306153831889.png)
      ![image-20210306153904961](https://github.com/zb1997/mynote/blob/main/tupian/image-20210306153904961.png)
   2. TIME_WAIT状态：在客户端收到服务端的结束报文之后，会等待两个MSL(报文最大生存时间)才会完全关闭，理由：
      1. 可靠的终止TCP连接：当报文7丢失时，服务端会重发报文6，客户端需要继续对这个报文回复，否则客户端将以复位报文段来回应服务器，服务器则认为这是一个错误，因为他期望的是一个像TCP报文7一样的确认报文
      2. 保证让迟到的报文段有足够的事件被识别并被丢弃：在linux系统上，一个TCP端口不能被同时多次打开，当一个TCP连接处于TIME_WAIT状态时，我们将无法立即使用改连接占用着的端口里建立一个新的连接，如果不存在TIME_WAIT状态，则应用程序能够立即建立一个和原来一样的连接，这个连接就可能会受到之前的数据包，这显然是不应该发生的
      3. 2个MSL的原因是TIME_WAIT状态能够确保网络上的两个传输方向上的未被接受的、迟到的报文段都已经消失，所以一个新的连接在2MSL时间后可以安全的建立

5. 复位报文段：特殊情况下，TCP连接的一端会向对方发送带RST标志的报文段，通知对方关闭连接或者重新建立连接，谈论其中的三种情况

   1. 访问不存在的端口或者端口处于TIME_WAIT状态
   2. 异常终止连接：TCP提供异常终止连接的方法，即给对方发送一个复位报文段，一端发送了复位报文段，发送端所有等待发送的数据都会被丢弃，应用程序可以使用socket选项SO_LINGER来发送复位报文段
   3. 处理板打开连接：如果TCP连接的一端由于某种原因没有发送结束报文段或者结束报文段由于网络原因没有发送二终止了连接，那么另外一端就处于半打开状态，当半打开状态的连接发送数据时，对方将会恢复一个复位报文段

6. TCP交互数据

7. TCP成块数据

8. 带外数据(Out Of Band)

9. TCP超时重传

   1. tcp重传策略：TCP一共执行5次重传。每次重传的时间都增加一倍，在重传失败的情况下，底层的IP和ARP开始接管连接，Linux有两个重要的内核参数与TCP超时重传相关： /proc/sys/net/ipv4/tcp_retries1和/proc/sys/net/ipv4/tcp_retries2。 前者指定在底层IP接管之前TCP最少执行的重传次数， 默认值是3。 后者指定连接放弃前TCP最多可以执行的重传次数， 默认值是15（一般对应13～30 min）   
   2. 虽然超时会导致重传，但是重传可以发生在超时之前，即快速重传

10. 拥塞控制   慢开始 拥塞避免 快重传 快恢复

    ​	https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E4%BC%A0%E8%BE%93%E5%B1%82.md这篇文章中有比较形象的说明


#### 第四章：TCP／IP通信案例

### 第二篇：深入解析高性能服务器编程

#### 第五章：linux网络编程基础API

1. socket地址api：
   1. 主机序(小端)和网络序(大端)
   2. 通用sockaddr   结构体sockaddr
   3. 专用sockaddr   结构体sockaddr_un sockaddr_in sockaddr_in6
   4. IP地址转换函数
   
2. 创建socket、命名、监听: create bind listen

3. 连接相关：接受、发起、关闭 accept 

4. 数据读写 send recv

   上面三个里面涉及很多的标志位，能够产生不同的效果

5. 带外标记

6. 地址信息函数

7. scoket选项 setsockopt getsockopt 选项对应的功能比较重要

8. 网络信息api